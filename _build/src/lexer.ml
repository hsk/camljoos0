# 2 "src/lexer.mll"
 
  open Parser
		   
  let get = Lexing.lexeme

  let keyword_table = Hashtbl.create 53
  let _ =
    List.iter (fun (kwd, tok) -> Hashtbl.add keyword_table kwd tok)
      [(*"abstract"    , ABSTRACT; *)
       "abstract"    , KEYWORD "abstract";
       "boolean"     , BOOLEAN;
(*       "break"       , BREAK; *)
       "break"       , KEYWORD "break";
(*       "byte"        , BYTE; *)
       "byte"        , KEYWORD "byte";
(*       "case"        , CASE; *)
       "case"        , KEYWORD "case";
(*       "catch"       , CATCH; *)
       "catch"       , KEYWORD "catch"; 
       "char"        , CHAR;
       "class"       , CLASS; 
(*       "const"       , CONST; *)
       "const"       , KEYWORD "const";
(*       "continue"    , CONTINUE; *)
       "continue"    , KEYWORD "continue";
(*       "default"     , DEFAULT; *)
       "default"     , KEYWORD "default";
(*       "do"          , DO; *)
       "do"          , KEYWORD "do";
(*       "double"      , DOUBLE; *)
       "double"      , KEYWORD "double";
       "else"        , ELSE;  
(*       "extends"     , EXTENDS; *)
       "extends"     , KEYWORD "extends"; 
(*       "final"       , FINAL; *)
       "final"       , KEYWORD "final";
(*       "finally"     , FINALLY; *)
       "finally"     , KEYWORD "finally";
(*       "float"       , FLOAT; *)
       "float"       , KEYWORD "float";
(*       "for"         , FOR; *)
       "for"         , KEYWORD "for";   
(*       "goto"        , GOTO; *)
       "goto"        , KEYWORD "goto";
       "if"          , IF;
(*       "implements"  , IMPLEMENTS; *)
       "implements"  , KEYWORD "implements";
(*       "import"      , IMPORT; *)
       "import"      , KEYWORD "import";
(*       "instanceof"  , INSTANCEOF; *)
       "instanceof"  , KEYWORD "instanceof";
       "int"         , INT;
(*       "interface"   , INTERFACE; *)
       "interface"   , KEYWORD "interface";
(*       "long"        , LONG; *)
       "long"        , KEYWORD "long";
(*       "native"      , NATIVE; *)
       "native"      , KEYWORD "native";
       "new"         , NEW;
(*       "package"     , PACKAGE; *)
       "package"     , KEYWORD "package";
(*       "private"     , PRIVATE; *)
       "private"     , KEYWORD "private";
       "protected"   , PROTECTED;   
       "public"      , PUBLIC;
       "return"      , RETURN;
(*       "short"       , SHORT; *)
       "short"       , KEYWORD "short";   
       "static"      , STATIC;
(*       "strictfp"    , STRICTFP; *)
       "strictfp"    , KEYWORD "strictfp";
(*       "super"       , SUPER; *)
       "super"       , KEYWORD "super"; 
(*       "switch"      , SWITCH; *)
       "switch"      , KEYWORD "switch";
(*       "synchronized", SYNCHRONIZED; *)
       "synchronized", KEYWORD "synchronized";
       "this"        , THIS;
(*       "throw"       , THROW; *)
       "throw"       , KEYWORD "throw";
       "throws"      , THROWS;
(*       "transient"   , TRANSIENT; *)
       "transient"   , KEYWORD "transient";
(*       "try"         , TRY; *)
       "try"         , KEYWORD "try";
       "void"        , VOID;
(*       "volatile"    , VOLATILE; *)
       "volatile"    , KEYWORD "volatile";
       "while"       , WHILE;
       
       "true"        , TRUE;
       "false"       , FALSE;
       "null"        , NULL;

     (* Extra JOOS0 keywords *)
       "String"      , STRING;
       "Exception"   , EXCEPTION;
       "System"      , SYSTEM;
       "out"         , OUT;
       "print"       , PRINT;
       "in"          , IN;
       "read"        , READ;
       "main"        , MAIN ]
      

  let tok_as_string t = match t with
    | EOF -> "eof"
  (* Keywords *)
(*    | ABSTRACT -> "abstract" *)
    | BOOLEAN -> "boolean"
(*    | BREAK -> "break" *)
(*    | BYTE -> "byte" *)
(*    | CASE -> "case" *)
(*    | CATCH -> "catch" *)
    | CHAR -> "char"
    | CLASS -> "class" 
(*    | CONST -> "const" *)
(*    | CONTINUE -> "continue" *)
(*    | DEFAULT -> "default" *)
(*    | DO -> "do" *)
(*    | DOUBLE -> "double" *)
    | ELSE -> "else"  
(*    | EXTENDS -> "extends" *)
(*    | FINAL -> "final" *)
(*    | FINALLY -> "finally" *)
(*    | FLOAT -> "float" *)
(*    | FOR -> "for" *)
(*    | GOTO -> "goto" *)
    | IF -> "if"
(*    | IMPLEMENTS -> "implements" *)
(*    | IMPORT -> "import" *)
(*    | INSTANCEOF -> "instanceof" *)
    | INT -> "int"
(*    | INTERFACE -> "interface" *)
(*    | LONG -> "long" *)
(*    | NATIVE -> "native" *)
    | NEW -> "new"
(*    | PACKAGE -> "package" *)
(*    | PRIVATE -> "private" *)
    | PROTECTED -> "protected"   
    | PUBLIC -> "public"
    | RETURN -> "return"
(*    | SHORT -> "short" *)
    | STATIC -> "static"
(*    | STRICTFP -> "strictfp" *)
(*    | SUPER -> "super" *)
(*    | SWITCH -> "switch" *)
(*    | SYNCHRONIZED -> "synchronized" *)
    | THIS -> "this"
(*    | THROW -> "throw" *)
    | THROWS -> "throws"
(*    | TRANSIENT -> "transient" *)
(*    | TRY -> "try" *)
    | VOID -> "void"
(*    | VOLATILE -> "volatile" *)
    | WHILE -> "while"
      
    | TRUE -> "true"
    | FALSE -> "false"
    | NULL -> "null"

    | KEYWORD s -> s

  (* Extra JOOS0 keywords *)
    | STRING -> "String" 
    | EXCEPTION -> "Exception"   
    | SYSTEM -> "System"
    | OUT -> "out"   
    | PRINT -> "print"
    | IN -> "in"
    | READ -> "read"
    | MAIN -> "main" 
      
  (* Delimiters *)
    | L_PAREN -> "("
    | R_PAREN -> ")"
    | L_BRACE -> "{"
    | R_BRACE -> "}"
    | L_BRACKET -> "["
    | R_BRACKET -> "]"
    | SEMICOLON -> ";"
    | COMMA -> ","
    | DOT -> "."

  (* Assignment and logic *)
    | ASSIGN -> "="
    | COMPLEMENT -> "!"
      
  (* Comparison *)
    | LT -> "<"
    | GT -> ">"
    | EQ -> "=="
    | LTEQ -> "<="
    | GTEQ -> ">="
    | NEQ -> "!="
      
      
  (* Arithmetic *)
    | PLUS -> "+"
    | MINUS -> "-"
    | STAR -> "*"
    | DIV -> "/"
    | AND -> "&"
    | OR -> "|"
    | XOR -> "^"
    | MOD -> "%"
      
  (* Literals and identifiers *)
    | INTEGER_LITERAL i -> "INTEGER_LITERAL" ^ i
    | STRING_LITERAL s -> "\"STRING_LITERAL\"" ^ s
    | IDENTIFIER s -> s (*"IDENTIFIER("^s^")"*)
      

# 216 "src/lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\001\001\201\000\017\000\222\255\223\255\224\255\225\255\
    \226\255\228\255\229\255\230\255\014\000\015\000\016\000\017\000\
    \239\255\240\255\241\255\242\255\243\255\244\255\245\255\246\255\
    \247\255\037\000\026\000\253\255\254\255\255\255\070\000\072\000\
    \250\255\251\255\071\000\252\255\076\000\248\255\234\255\231\255\
    \233\255\232\255\221\255\182\000\252\255\077\000\253\255\254\255\
    \255\255";
  Lexing.lex_backtrk = 
   "\255\255\035\000\255\255\033\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\020\000\019\000\018\000\017\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\028\000\002\000\255\255\255\255\255\255\006\000\255\255\
    \255\255\255\255\003\000\255\255\007\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\002\000\255\255\255\255\
    \255\255";
  Lexing.lex_default = 
   "\001\000\001\000\002\000\255\255\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\255\255\000\000\000\000\000\000\030\000\033\000\
    \000\000\000\000\255\255\000\000\255\255\000\000\000\000\000\000\
    \000\000\000\000\000\000\044\000\000\000\255\255\000\000\000\000\
    \000\000";
  Lexing.lex_trans = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\028\000\027\000\255\255\028\000\026\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \028\000\014\000\002\000\255\255\027\000\005\000\008\000\255\255\
    \024\000\023\000\009\000\011\000\017\000\010\000\016\000\025\000\
    \004\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\255\255\018\000\013\000\015\000\012\000\255\255\
    \255\255\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\041\000\040\000\039\000\038\000\031\000\
    \037\000\035\000\035\000\036\000\030\000\034\000\037\000\046\000\
    \000\000\000\000\000\000\020\000\255\255\019\000\006\000\000\000\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\032\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\022\000\007\000\021\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\000\000\255\255\255\255\
    \255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
    \046\000\000\000\000\000\045\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\255\255\000\000\000\000\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \047\000\000\000\000\000\000\000\000\000\048\000\000\000\000\000\
    \000\000\000\000\000\000\042\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \029\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\000\000\000\000\000\000\000\000\255\255\000\000\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255";
  Lexing.lex_check = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\026\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\012\000\013\000\014\000\015\000\025\000\
    \030\000\034\000\031\000\030\000\025\000\031\000\036\000\045\000\
    \255\255\255\255\255\255\000\000\000\000\000\000\000\000\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\031\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \043\000\255\255\255\255\043\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\002\000\255\255\255\255\002\000\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \043\000\255\255\255\255\255\255\255\255\043\000\255\255\255\255\
    \255\255\255\255\255\255\002\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\002\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\255\255\255\255\255\255\255\255\030\000\255\255\
    \031\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\001\000\001\000\001\000\001\000\
    \255\255\001\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\255\255\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\043\000\001\000\
    \001\000\001\000\001\000\255\255\001\000\001\000\001\000\001\000\
    \001\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\002\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \001\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \001\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\001\000";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec token lexbuf =
    __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 253 "src/lexer.mll"
           ( EOF )
# 395 "src/lexer.ml"

  | 1 ->
# 255 "src/lexer.mll"
                                    ( token lexbuf )
# 400 "src/lexer.ml"

  | 2 ->
# 256 "src/lexer.mll"
                                    ( Lexing.new_line lexbuf; token lexbuf )
# 405 "src/lexer.ml"

  | 3 ->
# 257 "src/lexer.mll"
                                    ( inside_comment false lexbuf )
# 410 "src/lexer.ml"

  | 4 ->
# 258 "src/lexer.mll"
                                    ( inside_comment false lexbuf )
# 415 "src/lexer.ml"

  | 5 ->
# 259 "src/lexer.mll"
                                    ( inside_comment true lexbuf )
# 420 "src/lexer.ml"

  | 6 ->
# 261 "src/lexer.mll"
                                    ( token lexbuf )
# 425 "src/lexer.ml"

  | 7 ->
# 263 "src/lexer.mll"
                                    ( Lexing.new_line lexbuf; token lexbuf )
# 430 "src/lexer.ml"

  | 8 ->
# 267 "src/lexer.mll"
                    ( L_PAREN )
# 435 "src/lexer.ml"

  | 9 ->
# 268 "src/lexer.mll"
                    ( R_PAREN )
# 440 "src/lexer.ml"

  | 10 ->
# 269 "src/lexer.mll"
                    ( L_BRACE )
# 445 "src/lexer.ml"

  | 11 ->
# 270 "src/lexer.mll"
                    ( R_BRACE )
# 450 "src/lexer.ml"

  | 12 ->
# 271 "src/lexer.mll"
                    ( L_BRACKET )
# 455 "src/lexer.ml"

  | 13 ->
# 272 "src/lexer.mll"
                    ( R_BRACKET )
# 460 "src/lexer.ml"

  | 14 ->
# 273 "src/lexer.mll"
                    ( SEMICOLON )
# 465 "src/lexer.ml"

  | 15 ->
# 274 "src/lexer.mll"
                    ( COMMA )
# 470 "src/lexer.ml"

  | 16 ->
# 275 "src/lexer.mll"
                    ( DOT )
# 475 "src/lexer.ml"

  | 17 ->
# 278 "src/lexer.mll"
                    ( ASSIGN )
# 480 "src/lexer.ml"

  | 18 ->
# 279 "src/lexer.mll"
                    ( COMPLEMENT )
# 485 "src/lexer.ml"

  | 19 ->
# 282 "src/lexer.mll"
                    ( LT )
# 490 "src/lexer.ml"

  | 20 ->
# 283 "src/lexer.mll"
                    ( GT )
# 495 "src/lexer.ml"

  | 21 ->
# 284 "src/lexer.mll"
                    ( EQ )
# 500 "src/lexer.ml"

  | 22 ->
# 285 "src/lexer.mll"
                    ( LTEQ )
# 505 "src/lexer.ml"

  | 23 ->
# 286 "src/lexer.mll"
                    ( GTEQ )
# 510 "src/lexer.ml"

  | 24 ->
# 287 "src/lexer.mll"
                    ( NEQ )
# 515 "src/lexer.ml"

  | 25 ->
# 290 "src/lexer.mll"
                    ( PLUS )
# 520 "src/lexer.ml"

  | 26 ->
# 291 "src/lexer.mll"
                    ( MINUS )
# 525 "src/lexer.ml"

  | 27 ->
# 292 "src/lexer.mll"
                    ( STAR )
# 530 "src/lexer.ml"

  | 28 ->
# 293 "src/lexer.mll"
                    ( DIV )
# 535 "src/lexer.ml"

  | 29 ->
# 294 "src/lexer.mll"
                    ( AND )
# 540 "src/lexer.ml"

  | 30 ->
# 295 "src/lexer.mll"
                    ( OR )
# 545 "src/lexer.ml"

  | 31 ->
# 296 "src/lexer.mll"
                    ( XOR )
# 550 "src/lexer.ml"

  | 32 ->
# 297 "src/lexer.mll"
                    ( MOD )
# 555 "src/lexer.ml"

  | 33 ->
let
# 300 "src/lexer.mll"
                       i
# 561 "src/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 300 "src/lexer.mll"
                                            ( INTEGER_LITERAL i )
# 565 "src/lexer.ml"

  | 34 ->
let
# 301 "src/lexer.mll"
                                 s
# 571 "src/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 301 "src/lexer.mll"
                                            ( STRING_LITERAL s )
# 575 "src/lexer.ml"

  | 35 ->
let
# 302 "src/lexer.mll"
                                         id
# 581 "src/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 302 "src/lexer.mll"
                                            ( try
						Hashtbl.find keyword_table id
                                              with Not_found ->
						IDENTIFIER id )
# 588 "src/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and inside_comment laststar lexbuf =
    __ocaml_lex_inside_comment_rec laststar lexbuf 43
and __ocaml_lex_inside_comment_rec laststar lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 310 "src/lexer.mll"
                                   ( if laststar
                                     then token lexbuf
                                     else inside_comment false lexbuf )
# 602 "src/lexer.ml"

  | 1 ->
# 313 "src/lexer.mll"
                                   ( inside_comment true lexbuf )
# 607 "src/lexer.ml"

  | 2 ->
# 314 "src/lexer.mll"
                                   ( Lexing.new_line lexbuf;
				     inside_comment false lexbuf )
# 613 "src/lexer.ml"

  | 3 ->
# 316 "src/lexer.mll"
                                   ( inside_comment false lexbuf )
# 618 "src/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_inside_comment_rec laststar lexbuf __ocaml_lex_state

;;

